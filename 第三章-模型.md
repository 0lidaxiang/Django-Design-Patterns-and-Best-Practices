
第三章 模型
-----------  

本章，我们将讨论以下话题：  
    模型的重要性
    类图表
    模型结构模式
    模型行为模式
    迁移

##M比V和C都更大
在Django中，模型是具有处理数据库的一种面向对象的方法的类。通常，每个类都引用一个数据库表，，每个属性都引用一个数据库列。你可以使用自动生成的API查询这些表。  

模型是很多其他组件的基础。只要你有一个模型，你可以快速地推导模型admin，模型表单，以及所有类型的通用视图。在每个例子中，你都需要下一个行或是两行代码，这样可以让它看上去没有太多魔法。  

模型也被用在更多超出你期望的地方。这书因为Django可以以多种方法运行。Django的一些切入点如下：  

    熟悉web请求-响应流程
    Django的交互式shell
    管理命令
    测试脚本
    异步任务队列比如Celery

在多数的这些例子中，模型模块要导入（作为django.setup()的一部分）。因此，最好保持模型没有任何不必要的依赖，或者导入任何的其他Django组件，比如视图。  

简而言之，恰当地设计模型是很重要的事情。现在，让我们从SuperBook模型设计开始。  

###注释

##模型搜寻
这是在SuperBook中确定模型的第一部分。通常对于一个先前尝试，我们只表示了基本模型，以及在类表中的表单的基本关系：  

图：略  

让我们忘掉模型一会儿，

像这样画一个模型的类表是推荐的。这个步骤某些属性或许丢失，不过你可以在之后补充细节。只要整个项目用图表表示出来，便可以轻松地分离app。  

这是创建这个表示的一些提示：  

    盒子表示目录，它变成模型。
    你写完的名词通常作为目录结束。
    箭头是双向的，表示Django中三种关系类型其中的一种：一对一，一对多（通过外键实现），和多对多。
    字段表明一对多关系


###分割model.py到多个文件
就像多数的Django组件那样，一个大的model.py文件可以在一个包内分割为多个文件。**package**通过一个目录来实现，它包含多个文件，目录中的一个文件必须是一个称为`__init__.py`特殊文件。  

所有可以在包级别暴露的定义都必须使用全局变量域定义在`__init__.py`中。例如，如果我们分割model.py到独立的类，在models子文件夹中的对应文件，比如，postable.py，post.py和comment.py, 之后`__init__.py`包会像这样：  

    from postable import Postable
    from post import Post
    from commnet import Comment

现在你可以像之前那样导入models.Post了。  

在`__init__.py`包中的任何其他代码都会在包运行时被导入。因此，它是一个任意级别包初始化代码的理想之地。  

##结构模式
本节包含多个版主你设计和构建模型的设计模式。  

###模式-规范化模型
**问题**：通过设计，模型实例的重复数据引起数据不一致。  

**解决方法**：通过规范化，分解模型到更小的模型。使用这些模型之间的逻辑关系来连接他们。  

###问题细节
想象一下，如果某人用下面的方法设计Post表（省略部分列）：  

|超级英雄的名字    |消息         |发布时间   |
|---------------


###详解
在我们看看完整地正常化方案之气，让我们用Django模型的上下文来个关于数据库规范化的简要说明。  

###规范化的三个步骤
规范化有助于你更有效地的存储书库。只要模型完全地的规范化处理，他们不会有冗余的数据，每个模型应该只包含逻辑上关联到自身的数据。  

这里给出一个简单的例子，如果我们规范化了Post表，这样我们就可以毫不含糊地引用发布消息的超级英雄，然后我们需要用一个独立的表来隔离用户细节。默认，Django已经创建了用户表。因此，你只需要在第一列中引用发布消息的用户的ID，一如下表所示：  

表格：略  

现在，不仅仅相同用户发布三条消息的清楚在列，而且我们可以通过查询用户表找到用户的正确的名字。  

通常来说，你会按照模型的规范化形式来设计模型，也会因为性能原因而有选择性地非规范化设计。在数据库中，**Normal Forms**是一组可以被应用于表，确保表被规范化的指南。一般我们建立第一，第二，第三规范表，尽管他们可以爬升至第五规范表。  

这接下来的例子中，我们规范化一个表，创建对应的Django模型。想象下有个名字称做“Sightings”的表格，它列出了某人第一次发现超级英雄使用能力或者特异功能。每个条目都提到了已知的原始身份，超能力，和第一次发现的地点，包括维度和经度。  

表格：略  

###第一个规范表（1NF）
为了确认第一个规范表格，这张表必须含有：  

    多个没有属性（cell）的值
    一个主键作为单独一列或者一组列（合成键）

让我们试着把表格转换为一个数据库表。明显地，我们的`Power`列破坏了第一个规则。  

更新过的表满足第一规范表。主键（用一个`*`标记）是`Name`和`Power`的合并，对于每一排它都应该是唯一的。  

表格：略  

###第二规范表
第二规范表必须满足所有第一规范表的条件。此外，它必须满足所有非主键列都必须依赖于整个主键的条件。  

在之前的表，我们注意到`Origin`只依赖于超级英雄，即，`Name`。不论我们谈论的是哪一个`Power`。因此，`Origin`不是完全地依赖于合成组件-`Name`和`Power`。  

这里，让我们只取出原始信息到一个独立的，称做`Origins`的表：  

表格：略  

现在`Sightings`表更新为兼容第二规范表，它大概是这个样子：  

表格：略  

###第三规范表
在第三规范表中，比表格必须满足第二规范表，而且应该额外满足

  
###Django模型

  
###性能和非规范化

  
##提示
**最佳实践**
*因设计而归法化，又因优化而非规范化*
例如，


  
##我们应该总是规范化吗？


  
##模式-模型mixins
**问题**：明显的模型含有重复的相同字段/或者方法，违反了DRY原则。  

**方案**：提取公共字段和方法多种目的的可重复使用的模型mixins中。  

##问题细节

##详解  

  
###模型mixins

   
##模式-用户账户
**问题**：每一个网站都存储一组不同的用户账户细节。然而，Django的内建User模型旨在真对认证细节。  

**方案**：用一个一对一关系的用户模型，创建一个用户账户类。  

##问题细节


  
##详解

  
###信号


  
###Admin


  
###多账户类型

##模式-服务模式  


###问题细节  

###详解  

##检索模式  

###模式-属性字段  

###问题细节  

###详解  

##提示
  
最佳实践


  
###缓存特性  

##模式-定制模型管理器  

###问题细节  

###详解  

###操作Querysets  

###链接多个Querysets  

##提示  

##迁移  

##总结
