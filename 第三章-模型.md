第三章 模型
-----------  

本章，我们将讨论以下话题：  
    模型的重要性
    类图表
    模型结构模式
    模型行为模式
    迁移

##M比V和C都更大
在Django中，模型是具有处理数据库的一种面向对象的方法的类。通常，每个类都引用一个数据库表，，每个属性都引用一个数据库列。你可以使用自动生成的API查询这些表。  

模型是很多其他组件的基础。只要你有一个模型，你可以快速地推导模型admin，模型表单，以及所有类型的通用视图。在每个例子中，你都需要下一个行或是两行代码，这样可以让它看上去没有太多魔法。  

模型也被用在更多超出你期望的地方。这书因为Django可以以多种方法运行。Django的一些切入点如下：  

    熟悉web请求-响应流程
    Django的交互式shell
    管理命令
    测试脚本
    异步任务队列比如Celery

在多数的这些例子中，模型模块要导入（作为django.setup()的一部分）。因此，最好保证模型远离任何不必要的依赖，或者导入任何的其他Django组件，比如视图。  

简而言之，恰当地设计模型是很重要的事情。现在，让我们从SuperBook模型设计开始。  

###注释
**自带午餐便当**  
*作者注释：SuperBook项目的进度会以这样的一个盒子出现。你可以跳过这个盒子，但是你会缺失一些领悟，经验以及在web一个应用项目中工作情境*  

史蒂夫和客户的第一周——超级英雄情报监控（简称为S.H.I.M）。简单来说，这是一个大杂烩。办公室是非常未来化的，可是不论做什么事情都是需要上百个审批和签字的。  

作为Django开发者的领队，史蒂夫已经配置好了中型的运行超过两天的4台虚拟机。第二天的一个早晨，机器自己不翼而飞了。一个附近的清洁机器人说，机器被法务部们给带走了，他们要对未经审批的软件安装做出处理。  

然而，CTO哈特给予史蒂夫了极大的帮助。他要求机器在一个小时之内完好无损地给还回去。他还对SuperBook项目做出了提前审批以避免将来任何阻碍。  

那个下午的稍晚些时候，史蒂夫给他带了一个午餐便当。身着一件米色外套和浅蓝色牛仔裤的哈特如约而至。尽管高出周围人许多，有着清爽面庞的他依旧那么帅气，那么平易近人。他问史蒂夫如果他之前是否尝试过构建一个60年代的超级英雄数据库。  

”嗯，对的，是哨兵项目么？“，史蒂夫说道。”是我设计的。数据库看上去被设计成了一个条目-属性-值形式的模式，有些地方我考虑用反模式。可能，这些天他们有一些超级英雄属性的小想法。哈特几乎等不到听完最后一句，他压低嗓门道：“没错。是我的错。另外，他们只给了我两天来设计整个架构。他们这是在要我老命啊！”  

听了这些，史蒂夫的嘴巴张的大大的，三明治也卡在口中。哈特微笑着道：“当然了，我还没有尽全力来做这件事。只要它成长为100万美元的单子，我们就可以多花点时间在这该死的数据库上了。SuperBook用它就能分分钟完事的，小史你说呢？”  

史蒂夫微微点头称是。他从来没有想过在这么样的地方将会有上百万的超级英雄出现。  


##模型搜寻
这是在SuperBook中确定模型的第一部分。通常对于一个早期试验，我们只表示了基本模型，以及在一个类表中的表单的基本关系：  

图：略  

让我们忘掉模型一会儿，来说说我们正在构建的对象术语。每个用户都有一个账户。用户可以写多个回复或者多篇文章。**Like**可以同时关联到一个单独的用户或者文章。  


推荐你像这样画一个模型的类表。这个步骤某些属性或许丢失，不过你可以在之后补充细节。只要整个项目用图表表示出来，便可以轻松地分离app。  

这是创建此表现的一些提示：  

    盒子表示条目，它将成为模型。
    名词通常作为条目的终止。
    箭头是双向的，表示Django中三种关系类型其中的一种：一对一，一对多（通过外键实现），和多对多。
    字段表明在基于条目-关系模型（ER-modle）的模型中定义了一对多关系。换句来说，星号是声明外键的地方。  

类图表可以映射到下面的Django代码中（它将遍及多个app）：  

    class Profile(models.Model):
        user = models.OnToOneField(User)

    class Post(models.Model):
        posted_by = models.ForeignKey(User)

    class Comment(models.Model):
        commented_by = models.ForeignKey(User)
        for_post = models.ForeignKey(Post)

    class Like(models.Model):
        liked_by = models.ForeignKey(User)
        post = models.ForeignKey(Post)

这之后，我们不会直接地引用*User*，而是使用更加普通的*settings.AUTH_USER_MODEL*来替代。  


###分割model.py到多个文件
就像多数的Django组件那样，一个大的model.py文件可以在一个包内分割为多个文件。**package**通过一个目录来实现，它包含多个文件，目录中的一个文件必须是一个称为`__init__.py`特殊文件。  

所有可以在包级别中暴露的定义都必须在`__init__.py`里使用全局变量域定义。例如，如果我们分割model.py到独立的类，models子文件夹中的对应文件，比如，postable.py，post.py和comment.py, 之后`__init__.py`包会像这样：  

    from postable import Postable
    from post import Post
    from commnet import Comment

现在你可以像之前那样导入models.Post了。  

在`__init__.py`包中的任何其他代码都会在包运行时被导入。因此，它是一个任意级别包初始化代码的理想之地。  

##结构模式
本节包含多个帮助你设计和构建模型的设计模式。  

###模式-规范化模型
**问题**：通过设计，模型实例的重复数据引起数据不一致。  

**解决方法**：通过规范化，分解模型到更小的模型。使用这些模型之间的逻辑关系来连接他们。  

###问题细节
想象一下，如果某人用下面的方法设计Post表（省略部分列）：  


| 超级英雄的名字        | 消息          | 发布时间  |
| ------------- |:-------------:| -----:|
| Captain Temper      | 消息已经发布过了？ | 2012/07/07/07:15 |
| Professor English      | 应该用“Is”而不是“Has"      |   2012/07/07/07:17 |
| Captain Temper | 消息已经发布过了？      |  2012/07/07/07:18 |
| Capt. Temper | 消息已经发布过了？      |  2012/07/07/07:19 |

  
我希望你注意到了在最后一行的超级英雄名字和之前不一致（船长一如既往的缺乏耐心）。  

如果我们看看第一列，我们也不确定哪一个拼写是正确的——`Captain Temper或者Capt.Temper`。这就是我们要通过规范化消除的一种数据冗余。  

###详解
在我们看下完整的规范方案，让我们用Django模型的上下文来个关于数据库规范化的简要说明。  

###规范化的三个步骤
规范化有助于你更有效地的存储数据库。只要模型完全地的规范化处理，他们就不会有冗余的数据，每个模型应该只包含逻辑上关联到自身的数据。  

这里给出一个简单的例子，如果我们规范化了Post表，我们就可以不模棱两可地引用发布消息的超级英雄，然后我们需要用一个独立的表来隔离用户细节。默认，Django已经创建了用户表。因此，你只需要在第一列中引用发布消息的用户的ID，一如下表所示：  

|用户ID|消息    |发布时间   |
|-----|:------:|---------:|
| 12      | 消息已经发布过了？ | 2012/07/07/07:15 |
| 8      | 应该用“Is”而不是“Has"      |   2012/07/07/07:17 |
| 12 | 消息已经发布过了？      |  2012/07/07/07:18 |
| 12 | 消息已经发布过了？      |  2012/07/07/07:19 |
  

现在，不仅仅相同用户发布三条消息的清楚在列，而且我们可以通过查询用户表找到用户的正确的名字。  

通常来说，你会按照模型的完全规规范化表来设计模型，也会因为性能原因而有选择性地非规范化设计。在数据库中，**Normal Forms**是一组可以被应用于表，确保表被规范化的指南。一般我们建立第一，第二，第三规范表，尽管他们可以递增至第五规范表。  

这接下来的例子中，我们规范化一个表，创建对应的Django模型。想象下有个名字称做“Sightings”的表格，它列出了某人第一次发现超级英雄使用能力或者特异功能。每个条目都提到了已知的原始身份，超能力，和第一次发现的地点，包括维度和经度。  

| 名字       | 原始信息     | 能力 |第一次使用记录（维度，经度，国家，时间） |
| ----------| :-----------:|:----:|----------------------------------:|
|Blitz      | Alien        |Freeze Flight|+40.75, -73.99; USA; 2014/07/03 23:12
|Hexa       |Scientist      |Telekinesis Flight|+35.68, +139.73; Japan; 2010/02/17 20:15
|Traveller  |Billonaire     |Time travel    |+43.62, +1.45, France; 2010/11/10 08:20

上面的地理数据提取自http://www.golombek.com/locations.html.  

###第一规范表（1NF）
为了确认第一个规范表格，这张表必须含有：  

    多个没有属性（cell）的值
    一个主键作为单独一列或者一组列（合成键）

让我们试着把表格转换为一个数据库表。明显地，我们的`Power`列破坏了第一个规则。  

更新过的表满足第一规范表。主键（用一个`*`标记）是`Name`和`Power`的合并，对于每一排它都应该是唯一的。  

|Name*|Origin|Power*|Latitude   |Longtitude |Country|Time       |
|-----|:----:|:----:|:---------:|:---------:|------------------:|
Blitz |Alien |Freeze|+40.75170  |-73.99420|USA|2014/07/03 23:12|
Blitz|Alien|Flight|+40.75170|-73.99420|USA|2013/03/12 11:30|
Hexa|Scientist|Telekinesis|+35.68330|+139.73330|Japan|2010/02/17 20:15|
Hexa|Scientist|Filght|+35.68330|+139.73330|Japan|2010/02/19 20:30|
Traveller|Billionaire|Time tavel|+43.61670|+1.45000|France|2010/11/10 08:20|



###第二规范表
第二规范表必须满足所有第一规范表的条件。此外，它必须满足所有非主键列都必须依赖于整个主键的条件。  

在之前的表，我们注意到`Origin`只依赖于超级英雄，即，`Name`。不论我们谈论的是哪一个`Power`。因此，`Origin`不是完全地依赖于合成组件-`Name`和`Power`。  

这里，让我们只取出原始信息到一个独立的，称做`Origins`的表：  

|Name*|Origin|
|-----|-----:|
Blitz|Alien|
Hexa|Scientist|
Traveller|Billionaire|
  

现在`Sightings`表更新为兼容第二规范表，它大概是这个样子：  

|Name*|Power*|Latitude   |Longtitude |Country|Time       |
|-----|:----:|:---------:|:---------:|------------------:|
Blitz |Freeze|+40.75170  |-73.99420|USA|2014/07/03 23:12|
Blitz||Flight|+40.75170|-73.99420|USA|2013/03/12 11:30|
Hexa|Telekinesis|+35.68330|+139.73330|Japan|2010/02/17 20:15|
Hexa|Filght|+35.68330|+139.73330|Japan|2010/02/19 20:30|
Traveller|Time tavel|+43.61670|+1.45000|France|2010/11/10 08:20|
  

###第三规范表
在第三规范表中，比表格必须满足第二规范表，而且应该额外满足所有的非主键列都直接依赖整个主键，而且这些非主键列都是互相独立的这个条件。  

考虑下`Country`类。给出`维度`和`经度`，你可以轻松地得出`Country`列。即使观测到超级英雄的地方依赖于`Name-Power`合成键，但是它只是间接地依赖他们。  

因此，我们把详细地址分离到一个独立的国家表格中：  

|Location ID|Latitude*|Longtitude*|Country|
|-----------|:-------:|:---------:|------:|
1|+40.75170|-73.99420|USA|
2|+35.68330|+139.73330|Japan|
3|+43.61670|+1.45000|France|
  

现在`Sightings`表格的第三规范表大抵如此：  

|User ID*|Power*|Location ID|Time|
---------|:----:|:---------:|---:|
2|Freeze|1|2014/0703 23:12
2|Flight|1|2013/03/12 11:30
4|Telekinesis|2|2010/02/17 20:15
4|Flight|2|2010/02/19 20:30
7|Time tavel|3|2010/11/10 08:20
  

如之前所做的那样，我们用对应的`User ID`替换了超级英雄的名字，这个用户ID用来引用用户表格。

###Django模型
现在我们可以看看这些规范化的表格可以用来表现Django模型。Django中并不直接支持合成键。这里用到的解决方案是应用代理键，以及在`Meta`类中指定`unique_together`属性：  

    class Origin(models.Model):
        superhero = models.ForeignKey(settings.AUTH_USER_MODEL)
        origin = models.CharField(max_length=100)

    class Location(models.Model):
        latitude = models.FloatField()
        longtitude = models.FloatField()
        country = models.CharField(max_length=100)

        class Meta:
            unique_together = ("latitude", "longtitude")

    class Sighting(models.Model):
        superhero = models.ForeignKey(settings.AUTH_USER_MODEL)
        power = models.CharField(max_length=100)
        location = models.ForeignKey(Location)
        sighted_on = models.DateTimeField()

        class Meta:
            unique_together = ("superhero", "power")


###性能和非规范化
规范化可能对性能有不利的影响。随着模型的增长，需要应答查询的连接数也随之增加。例如，要在美国发现具有冷冻能力的超级英雄的数量，你需要连接四个表格。先前的内容规范后，任何信息都可以通过查询一个单独的表格被找到。  

你应该设计模式以保持数据规范化。这可以维持数据的完整。然而，如果你面临扩展性问题，你可以有选择性地从这些模型取得数据以生成非规范化的数据。  
  
##提示
**最佳实践**
*因设计而规范，又因优化而非规范*
例如，在一个确定的国家中计算观测次数是非常普通的，然后将观测次数作为一个附加的字段到`Location`模型。现在，你可以使用Django ORM 继承其他的查询，而不是一个缓存的值。  

然而，你需要在每次添加或者移除观测时更新这个计数。你需要添加该计算到*Singhting*的`save`方法，添加一个信号处理器，甚至使用一个异步任务去计算。  

如果你有一个跨越多个表的负责查询，比如国家的超能力计算，你需要创建一个独立的非规范表格。就像前面那样，我们需要在每一次规范化模型中的数据改变时更新这个非规范的表格。  

令人惊讶的是非规范化在大型的网站中是非常普遍的，因为它是数度和存储空间两者之间的折衷。今天的存储空间已经比较便宜了，然而速度也是用户体验中至关重要的一环。因此，如果你的查询耗时过于久的话，那么就需要考虑非规范化了。  

##我们应该一直使用规范化吗？
过多的规范化是是件不必要的事。有时候，它可以引入一个非必需的能够重复更新和查询的表格。  

例如，你的`User`模型或许有好多个家庭地址的字段，你可以规范这些字段到一个`Address`模型中。可是，多数情况下，把一个额外的表引进数据库是没有必要的。  

与其针对大多数的非规范化设计，不如在代码重构之前仔细地衡量每个非规范化的机会，对性能和速度上做出一个折衷的选择。

  
##模式-模型mixins
**问题**：明显地模型含有重复的相同字段/或者方法，违反了DRY原则。  

**方案**：提取公共字段和方法到各种不同的可重复使用的模型mixins中。  

##问题细节
设计模型之时，你或许某些个公共属性或者行为跨类共享。烈日，`Post`和`Comment`模型需要一直跟踪自己的`created`日期和`modified`日期。手动地复制-粘贴字段和它们所关联的方法并不符合DRY原则。  

由于Django的模型是类，像合成以及继承这样的面向对象方法都是可以选择的解决方案。然而，合成（具有包含一个共享类实例的属性）需要一个额外的间接地访问字段的标准。  

继承是有技巧的。我们使用一个`Post`和`Comment`的公共基类。然而，在Django中有三种类型的继承：**concrete（具体）**, **abstract（抽象）**, 和**proxy（代理）**。  

具体继承的运行是源于基类，就像你在Python类中通常用到的那样。不过，在Django中，这个基类将被映射到一个独立的表中。每次你访问基本字段时，都需要一个准确的连接。这会带来非常糟糕的性能问题。  

代理继承只能添加新的行为到父类。你不能够添加新字段。因此，这种情况下它也不大好用。  

最后，我们只有托付于抽象继承了。

##详解  
抽象基类是用于模型之间共享数据和行为的游戏简洁方案。当你定义一个基类时，它在数据中没有创建任何与之对象的表。反而，这些字段是在派生的非基类中创建的。  

访问抽象基类字段不要`JOIN`语句。有支配的字段结构表也是不解自明的。对于这些优势，大多数的Django项目都使用抽象基类实现公共字段或者方法。  

使用抽象模型是局限的：  
    
    它们不能够拥有外键或者来自其他模型的多対多字段。
    它们不能够被实例化或者保存。
    它们不能够直接用在查询中，因为它没有管理器。  

下面是post和comment类如何使用一个抽象基类初始设计的：  

    class Postable(models.Model):
        created = models.DateTimeField(auto_now_add=True)
        modified = modified.DateTimeField(auto_now=True)
        message = models.TextField(max_length=500)

        class Meta:
            abstract = True


    class Post(Postable):
        ...


    class Comment(Postable):
        ...
  
要将一个模型转换到抽象基类，你需要在它的内部`Meta`类中写上`abstract = True`。这里的`Postable`是一个抽象基类。可是，它不是那么的可复用。  

实际上，如果有一个类含有`created`和`modified`字段，我们在后面就可以在附近的任何需要时间戳的模型中重复使用这个时间戳功能。  

###模型mixins
模型mixins是一个可以把抽象基类当作父类来添加的模型。不像其他的语法，比如Java那样，Python支持多种继承。因此，你可以列出一个模型的任意数量的父类。  

Mixins应该是互相垂直的而且易于组合的。把一个mixin放进基类的列表，这些mixin应该可以正常运行。这样看来，它们在行为上更类似于合成而非继承。  

较小的mixin的会更好。不论何时一个mixin变得庞大，而且又违反了独立响应原则，就要考虑把它重构到一个更小的类。就让一个mixin一次做好一件吧。  

在前面的例子中，模型mixin用于更新`created`和`modified`的时间可以轻松地分解出来，一如下面代码所示：  

    class TimeStampedModel(models.Model):
        created = modified.TimeStampModel(auto_now_add=True)
        modified = modified.DateTimeField(auto_now=True)

        class Meta:
            abstract = True


    class Postable(TimeStampedModel):
        message = models.TextField(max_length=500)
        ...

        class Meta:
            abstract = True


    class Post(Postable):
        ...


    class Comment(Postable):
        ...

  
我们现在有两个超类了。不过，功能之间都完全地独立。mixin可以分离到自己的模块之内，并且另外的上下文中被复用。  
   
##模式-用户账户
**问题**：每一个网站都存储一组不同的用户账户细节。然而，Django的内建User模型旨在针对认证细节。  

**方案**：用一个一对一关系的用户模型，创建一个用户账户类。  

##问题细节
Django提供一个开箱即用的相当不错的User模型。你可以在创建超级用户或者登录amdin接口的时候用到它。它含有少量的基本字段，比如全名，用户名，和电子邮件。  

然而，大多数的现实世界项目都保留了很多关于用户的信息，比如他们的地址，喜欢的电影，或者它们的超能力。打Django1.5开始，默认的User模型就可以被扩展或者替换掉。不过，官方文档极力推荐只存储认证数据，即便是在定制的用户模型中也是如此（毕竟，用户模型也是所属于`auth`这个app的）。  

某些项目是需要多种类型的用户的。例如，SuperBook可以被超级英雄和非超级英雄所使用。这里或许会有一些公共字段，以及基于用户类型的不同字段。  

##详解
官方推荐解决方案是创建一个用户账户模型。它应该和用户模型有一个一对一的关系。其余的全部用户信息都存储于该模型：  

    class Profile(models.Model):
        user = models.OnToOneField(settings.AUTH_USER_MODEL, primary_key=True)
这里推荐你明确的将`primary_key`赋值为`True`以阻止类似PostgreSQL这样的数据库后端中的并发问题。剩下的模型可以包含其他的任何用户详情，比如生日，喜好色彩，等等。  

设计账户模型之时，建议所有的账户详情字段都必须是非空的，或者含有一个默认值。凭直觉我们就知道用户在注册时是不可能填写完所有的账户细节的。此外，我们也要确保创建账户实例时，信号处理器没有传递任何初始参数。  

###信号
理论上，每一次用户模型的创建都必须把对应的用户账户实例创建好。这个操作通常使用信号来完成。例如，我们可以使用下面的信号处理器侦听用户模型的`post_save`信号：  

    # signals.py
    from django.db.models.signals import post_save
    from django.dispatch import receiver
    from django.conf import settings
    from . import models


    @receiver(post_save, sender=settings.AUTH_USER_MODEL)
    def create_profile_handler(sender, instance, created, **kwargs):
        if not created:
            return
        # Create the profile object, only if it is newly created
        profile = models.Profile(user=instance)
        profile.save()

注意账户模型除了用户实例之外没有传递额外的参数。  

之前没有指定初始信号代码的地方。通常，它们在`models.py`中（这是不可靠的）导入或者执行。不过，随着Django 1.7的app载入重构，应用初始化代码位置的问题也很好的解决了。  

首先，为你的应用创建一个`__init__.py`包以引用应用的`ProfileConfig`:  

    default_app_config = "profile.apps.ProfileConfig"

接下来是`app.py`中，子类`ProfileConfig`的方法，可于`ready`方法中配置信号：  

    # app.py
    from django.apps import AppConfig


    class ProfileConfig(AppConfig):
        name = "profiles"
        verbose_name = "User Profiles"


        def ready(self):
            from . import signals

随着信号的配置，对所有的用户来说，访问`user.profile`应该都返回一个`Profile`对象，即使是最新创建的用户也是如此。  

###Admin
现在，用户的详情为存在admin内的两个不同地方：普通用户admin页面中的认证细节，在一个独立账户admin页面中的相同用户的补充账户详情。但是这样做非常麻烦。  

为了操作方便，账户admin可以通过定义一个自定义的`UserAdmin`嵌入到默认的用户admin中：  

    # admin.py
    from django.contrib import admin
    from .models import Profile
    from django.contrib.auth.models import User


    class UserProfileInline(admin.StackedInline):
        model = Profile


    class UserAdmin(admin.UserAdmin):
        inlines = [UserProfileInline]


    admin.site.unregister(User)
    admin.site.register(User, UserAdmin)

  
###多账户类型
假设在应用中你需要几种类型的用户账户。这里需要有一个字段去跟踪用户使用的是哪一种账户类型。账户数据本身需要存储在独立的模型中，或者存储在一个统一的模型中。  

建议使用聚合账户方法因为它让改变


##模式-服务模式  


###问题细节  

###详解  

##检索模式  

###模式-属性字段  

###问题细节  

###详解  

##提示
  
最佳实践


  
###缓存特性  

##模式-定制模型管理器  

###问题细节  

###详解  

###操作Querysets  

###链接多个Querysets  

##提示  

##迁移  

##总结
